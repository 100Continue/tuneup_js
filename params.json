{"name":"Tuneup js","tagline":"A JavaScript library to ease automated iOS UI testing with UIAutomation and Instruments","body":"# Overview #\r\nTune-up is a collection of JavaScript utilities that builds upon and improves\r\nthe `UIAutomation` library provided by Apple for testing iOS applications via\r\nInstruments (get it? \"tune-up\"? Instruments? get it?).\r\n\r\nWhile the JavaScript library provided by Apple is fairly complete and robust,\r\nit is a bit wordy and repetitive at times. This project aims to reduce as much\r\npain as possible when writing UI tests by enhancing the existing API. It also\r\nprovides some basic structure for your tests in a manner familiar to most\r\ntesters.\r\n\r\n# Installation #\r\nPut the files for this project in the same location as your test scripts\r\nthat your run from Instruments. I like to use git submodules for third-party\r\nlibraries like so:\r\n\r\n    git submodule add git://github.com/alexvollmer/tuneup_js.git tuneup\r\n\r\nThen at the top of each test script include the following:\r\n\r\n    #import \"tuneup/tuneup.js\"\r\n\r\nRegardless of how you like to structure your tests, the path in the initial\r\n`#import` statement in your test script needs to be relative to the path\r\nof the tuneup library.\r\n\r\n# Test Structure #\r\nTo create a test case, use the `test()` function, which takes the name of\r\nthe test case as a string, and a function. The function will be given a\r\n`UIATarget` instance and a `UIAApplication` instance. For example:\r\n\r\n    test(\"Sign-In Screen\", function(target, app) {\r\n      // The target and app arguments are your portals into the running application\r\n      // Exercise and validate to your heart's content\r\n    });\r\n\r\n    test(\"Sign-out Screen\", function(target, app) {\r\n      // now exercise and validate the sign-out screen\r\n    });\r\n\r\nSee the `test.js` file for details.\r\n\r\n## Assertions ##\r\nTune-up comes with a handful of basic xUnit-like assertions (and more are on\r\nthe way). For now though, the basic assertions supported are:\r\n\r\n  * `assertNotNull`\r\n  * `assertEquals`\r\n  * `assertMatch`\r\n  * `assertTrue`\r\n  * `assertFalse`\r\n  * `assertWindow` (more on this below)\r\n  * `fail`\r\n\r\nSee the `assertions.js` file for all the details.\r\n\r\n## Window Assertions ##\r\nA common theme in writing integration tests for \"screen flows\" is the\r\nrepetitive cycle of making several assertions on a screen, then engaging some\r\nuser-control after all of the assertions pass. With the UIAutomation API as it\r\nis, it's easy to lose sight of this structure when bogged down in the syntax of\r\nasserting and navigating the user interface.\r\n\r\nTo make this cycle more obvious, and cut down on unnecessary verbosity, use the\r\n`assertWindow` function. It works by applying a given JavaScript object literal\r\nto the current main window (UIAWindow instance).\r\n\r\nThe full details are documented in `assertions.js`, but here's a taste of what\r\nthis assertion can do for your tests. Prior to `assertWindow` you would have\r\nto do something like this:\r\n\r\n    test(\"my test\", function(target, app) {\r\n      mainWindow = app.mainWindow();\r\n      navBar = mainWindow.navigationBar();\r\n      leftButton = navBar.leftButton();\r\n      rightButton = navBar.rightButton();\r\n\r\n      assertEquals(\"Back\", leftButton.name());\r\n      assertEquals(\"Done\", rightButton.name());\r\n\r\n      tableViews = mainWindow.tableViews();\r\n      assertEquals(1, tableViews.length);\r\n      table = tableViews[0];\r\n\r\n      assertEquals(\"First Name\", table.groups()[0].staticTexts()[0].name());\r\n      assertEquals(\"Last Name\", table.groups()[1].staticTexts()[0].name());\r\n\r\n      assertEquals(\"Fred\", table.cells()[0].name());\r\n      assertEquals(\"Flintstone\", table.cells()[1].name());\r\n    });\r\n\r\nWith `assertWindow`, you can boil it down to this:\r\n\r\n    test(\"my test\", function(target, app) {\r\n      assertWindow({\r\n        navigationBar: {\r\n          leftButton: { name: \"Back\" },\r\n          rightButton: { name: \"Done\" }\r\n        },\r\n        tableViews: [\r\n          {\r\n            groups: [\r\n              { name: \"First Name\" },\r\n              { name: \"Last Name\" }\r\n            ],\r\n            cells: [\r\n              { name: \"Fred\" },\r\n              { name: \"Flintstone\" }\r\n            ]\r\n          }\r\n        ]\r\n      });\r\n    });\r\n\r\nYou can do more than just match string literals. Check out the full\r\ndocumentation in `assertions.js` for all the details.\r\n\r\n### Window Assertions for Universal Applications ###\r\nIf you have a Universal Application and want to maintain a single set of test\r\nfiles, you can mark specific properties to match by adding a \"~ipad\" or\r\n\"~iphone\" extension to the property name. When you do this, you need to quote\r\nthe property name instead using a literal, like so:\r\n\r\n    test(\"my test\", function(target, app) {\r\n      assertWindow({\r\n        \"navigationBar~iphone\": {\r\n          leftButton: { name: \"Back\" },\r\n          rightButton: { name: \"Done\" }\r\n        },\r\n        \"navigationBar~ipad\": {\r\n          leftButton: null,\r\n          rightButton: { name: \"Cancel\" }\r\n        },\r\n      });\r\n    });\r\n\r\nNote that the \"~iphone\" extension should work for iPod Touch devices also.\r\n\r\nThis convention is derived for how device-specific images are loaded on both\r\niPad and iPhone/iPod devices. Hopefully it looks somewhat familiar.\r\n\r\n## UIAutomation Extensions ##\r\nThe `UIAutomation` library is pretty full-featured, but is a little wordy.\r\nTune-up provides several extensions to the built-in `UIAutomation` classes in\r\nan attempt to cut down on the verbosity of your tests.\r\n\r\nSee the `uiautomation-ext.js` for details.\r\n\r\n# Running Tests #\r\nStarting in iOS 5, Apple provided a way to run Instruments from the\r\ncommand-line. However, it's a bit fiddly and is very general-purpose\r\nso doing anything _useful_ with the output is kind of a pain.\r\n\r\nTuneup now provides a Ruby script (`run-test`) to run your test scripts.\r\nThe runner will parse the output of your test and produce a proper\r\nUNIX exit code based on whether or not your tests succeeded. It also\r\nprovides some niceties like automatically specifying the full-path\r\nto your test script if you don't provide one.\r\n\r\nHave a look at `run-test --help` to be sure you're not missing any newly\r\nadded features like fancy colors.\r\n\r\nTo use the runner, invoke it like so:\r\n\r\n    [path to tuneup]/test_runner/run <app bundle> <test script> <output directory> [optional args]\r\n\r\nNormally the name of the app bundle will suffice for the `<app bundle>`\r\nargument. If you're running your tests on the simulator the newest bundle\r\nwill be located automatically. If that fails, or if you want to manually\r\nspecify the bundle to be used, you need to provide a _fully-qualified_\r\npath to the app bundle, which will be buried somewhere in\r\n`~/Library/Developer/Xcode/DerivedData`.\r\n\r\nThe `<test script>` argument specifies the JavaScript test file and the\r\n`<output directory>` is where the resulting Instruments output like screenshots\r\nand reports should go.\r\n\r\nRun the script with `-h` or `--help` for a full explanation of supported options.\r\n\r\n## Device or Simulator ##\r\nIf you provide the optional argument `-d DEVICE`, you can tell Instruments\r\nto run your test against a real device (identified by UDID). You can also\r\npass `dynamic` and tuneup will find the UDID at runtime. If this argument is\r\nnot provided, the runner will run against the simulator.\r\n\r\n## Preprocessing ##\r\nThe Instruments preprocessor causes a lot of headache due to its inability\r\nto handle `#import` statements properly. If you pass `-p`, the script will\r\ncreate a temp file, resolve any imports and inline the referenced files\r\n(only once).\r\n\r\n## Selecting tests ##\r\nIf you don't want to run your whole test suite, you can selectively run\r\ntests by specifying the argument `-r TEST`. Whatever you pass for `TEST`\r\nwill be used as regex to match any `title` of your tests.\r\n\r\n## XML reports ##\r\nTuneup can generate Xunit style reports that can be analyzed by\r\nany compatible tool, like Jenkins. Given the parameter `-x` a XML report\r\nwill be generated in the output directory.\r\n\r\n## Screenshots assertion ##\r\nTuneup can compare captured screen images against provided reference images and\r\ngenerate diff images for them. This function relies on `compare` utility from\r\n[ImageMagick](http://www.imagemagick.org). Steps to activate this feature:\r\n\r\n1. `brew install imagemagick`.\r\n2. In your test script create `ImageAsserter`:\r\n```javascript\r\n/**\r\n* tuneup_folder     - folder with tuneup sources\r\n* output_folder     - folder with test results\r\n* ref_images_folder - folder with you reference images\r\n**/\r\ncreateImageAsserter('tuneup_folder', 'output_folder', 'ref_images_folder');\r\n```\r\n\r\n3. Assert current screen against reference image with `assertScreenMatchesImageNamed`\r\nhelper.\r\n4. Generated diff images are located in `screens_diff` subfolder of the output\r\nfolder.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}